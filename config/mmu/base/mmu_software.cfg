## Happy Hare supporting macros

[save_variables]
filename: /root/printer_data/config/mmu/mmu_vars.cfg

########################################################################
# Tool change macros
# This is automatically created on installation but you can increase
# or reduce this list to match your number of tools in operation
#######################################################################
[gcode_macro T0]
gcode: MMU_CHANGE_TOOL TOOL=0
[gcode_macro T1]
gcode: MMU_CHANGE_TOOL TOOL=1
[gcode_macro T2]
gcode: MMU_CHANGE_TOOL TOOL=2
[gcode_macro T3]
gcode: MMU_CHANGE_TOOL TOOL=3
[gcode_macro T4]
gcode: MMU_CHANGE_TOOL TOOL=4
[gcode_macro T5] 
gcode: MMU_CHANGE_TOOL TOOL=5



########################################################################
# Simplified subset of commands just for visability in Mainsail/Fluidd UI
# until custom panel is complete!
# The __ is a trick because it is not displayed by the UI but the fact
# the macros are defined here means they are still seen by Mainsail/Fluidd
########################################################################
[gcode_macro MMU__EJECT]
gcode: MMU_EJECT

[gcode_macro MMU__HOME]
gcode:
    {% set TOOL = params.TOOL|default(0)|int %}
    {% set FORCE_UNLOAD = params.FORCE_UNLOAD|default(0)|int %}
    MMU_HOME TOOL={TOOL} FORCE_UNLOAD={FORCE_UNLOAD}

[gcode_macro MMU__STATUS]
gcode: MMU_STATUS

[gcode_macro MMU__MOTORS_OFF]
gcode: MMU_MOTORS_OFF

[gcode_macro MMU__SERVO]
gcode:
    {% set POS = params.POS|default("up")|string %}
    MMU_SERVO POS={POS}

[gcode_macro MMU__SELECT_TOOL]
gcode:
    {% set TOOL = params.TOOL|default(0)|int %}
    MMU_SELECT TOOL={TOOL}

[gcode_macro MMU__SELECT_BYPASS]
gcode: MMU_SELECT_BYPASS

[gcode_macro MMU__LOAD_BYPASS]
gcode: MMU_LOAD

[gcode_macro MMU__RECOVER]
gcode: MMU_RECOVER

[gcode_macro MMU__PRELOAD]
gcode:
    {% set GATE = params.GATE|default(0)|int %}
    MMU_PRELOAD GATE={GATE}

[gcode_macro MMU__CHECK_GATE]
gcode:
    {% set GATE = params.GATE|default(-1)|int %}
    {% set TOOL = params.GATE|default(-1)|int %}
    {% set GATES = params.GATE|default('!')|string %}
    {% set TOOLS = params.GATE|default('!')|string %}
    MMU_CHECK_GATE GATE={GATE} TOOL={TOOL} GATES={GATES} TOOLS={TOOLS}

# Aliases (for backward compatibility)...

[gcode_macro MMU_CHANGE_TOOL_STANDALONE]
description: Convenience macro for inclusion in print_start for initial tool load
gcode:
    MMU_CHANGE_TOOL {rawparams} STANDALONE=1

[gcode_macro MMU_CHECK_GATES]
description: Alias for updated macro name of MMU_CHECK_GATE
gcode:
    MMU_CHECK_GATE {rawparams}


########################################################################
# Standalone Tip Forming (also helps with rapid tuning of Slicer values)
########################################################################
[gcode_macro _MMU_FORM_TIP_STANDALONE]
description: Standalone macro that mimics SuperSlicer process

# Unloading and Ramming values - Initial moves to form and shape tip
variable_unloading_speed_start: 80     # Fast here to seperate the filament from meltzone (Very intitial retract SS uses distance of E-15)
variable_unloading_speed: 18           # Too fast forms excessively long tip or hair. Slow is better here UNLOADING_SPEED_START/COOLING_MOVES seems a good start
variable_ramming_volume: 0             # (mm^3) SS default values = 2, 5, 9, 13, 18, 23, 27. Only Used to Simulate SS Ramming during standalone
variable_ss_ramming: 0                 # Set to 0 for standalone ramming (RAMMING_VOLUME), 1 to let the slicer do it (i.e. turn off for standalone)

# Cooling Move Values - To cool the tip formed and separate from strings
variable_cooling_tube_position: 35     # Dragon ST: 35, Dragon HF: 30, Mosquito: 30, Revo: 35, Phaetus Rapido HF: 43;  Measured from Top of Heater Block to Top of Heatsink
variable_cooling_tube_length: 10       # Dragon ST: 15, Dragon HF: 10, Mosquito: 20, Revo: 10, Phaetus Rapido HF: 22; Measured from Nozzle to Top of Heater Block
variable_initial_cooling_speed: 10     # Slow to solidify tip and cool string if formed.
variable_final_cooling_speed: 50       # High speed break the string formed. Too fast = tip deformation during eject. Too Slow = long string/no seperation
variable_toolchange_temp: 0            # Used if you want to lower temp during toolchanges default 0
variable_cooling_moves: 4              # 2-4 is a good start

# SkinnyDip values - To burn off VERY FINE hairs only (This is NOT for long tip reshaping)
variable_use_skinnydip: 1              # Tune this LAST, this is for removal of VERY FINE hairs only (Different than a long tip)
variable_skinnydip_distance: 30        # Start just under Cooling_tube_position and increase - Will depend on how much Ramming Volume is used
variable_dip_insertion_speed: 30       # Medium-Slow - Just long enough to melt the fine hairs. Too slow will pull up molten filament
variable_dip_extraction_speed: 70      # Around 2x Insertion speed, Prevents forming new hairs
variable_melt_zone_pause: 0            # Milliseconds - default 0
variable_cooling_zone_pause: 0         # Milliseconds - default 0 - If you need to adjust here its possible Dip Insertion too slow
variable_use_fast_skinnydip: 0         # Skip the toolhead temp change during skinnydip move - default 0

# Final Eject - for standalone tuning only. Automatically set by `MMU_FORM_TIP` command
variable_final_eject: 0                # Default 0, enable during standalone tuning process to eject the filament

# Park filament ready to eject
variable_parking_distance: 0           # Final filament parking position after final cooling move, 0 will leave filament where it naturally ends up

gcode:
    # Initialize Paramaters
    {% set UNLOADING_SPEED_START = params.UNLOADING_SPEED_START|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['unloading_speed_start']) %}
    {% set UNLOADING_SPEED = params.UNLOADING_SPEED|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['unloading_speed']) %}
    {% set RAMMING_VOLUME = params.RAMMING_VOLUME|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['ramming_volume']) %}
    {% set SS_RAMMING = params.SS_RAMMING|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['ss_ramming']) %}
    {% set COOLING_TUBE_LENGTH = params.COOLING_TUBE_LENGTH|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['cooling_tube_length']) %}
    {% set COOLING_TUBE_POSITION = params.COOLING_TUBE_POSITION|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['cooling_tube_position']) %}
    {% set INITIAL_COOLING_SPEED = params.INITIAL_COOLING_SPEED|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['initial_cooling_speed']) %}
    {% set FINAL_COOLING_SPEED = params.FINAL_COOLING_SPEED|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['final_cooling_speed']) %}
    {% set COOLING_MOVES = params.COOLING_MOVES|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['cooling_moves']) %}
    {% set TOOLCHANGE_TEMP = params.TOOLCHANGE_TEMP|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['toolchange_temp']) %}
    {% set USE_SKINNYDIP = params.USE_SKINNYDIP|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['use_skinnydip']) %}
    {% set USE_FAST_SKINNYDIP = params.USE_FAST_SKINNYDIP|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['use_fast_skinnydip']) %}
    {% set SKINNYDIP_DISTANCE = params.SKINNYDIP_DISTANCE|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['skinnydip_distance']) %}
    {% set DIP_INSERTION_SPEED = params.DIP_INSERTION_SPEED|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['dip_insertion_speed']) %}
    {% set DIP_EXTRACTION_SPEED = params.DIP_EXTRACTION_SPEED|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['dip_extraction_speed']) %}
    {% set MELT_ZONE_PAUSE = params.MELT_ZONE_PAUSE|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['melt_zone_pause']) %}
    {% set COOLING_ZONE_PAUSE = params.COOLING_ZONE_PAUSE|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['cooling_zone_pause']) %}
    {% set PARKING_DISTANCE = params.PARKING_DISTANCE|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['parking_distance']) %}
    {% set FINAL_EJECT = params.FINAL_EJECT|default(printer['gcode_macro _MMU_FORM_TIP_STANDALONE']['final_eject']) %}

    G91
    M83
    G92 E0
    
    #---------------------------------#
    #-Tip forming Process begins here-#
    #---------------------------------#

    SET_PRESSURE_ADVANCE ADVANCE=0
    {% set OLD_TEMP = printer.extruder.target %}
    {% if SS_RAMMING|int == 0 and RAMMING_VOLUME|int > 0 %} # Standalone Ramming
        {% set RATIO = (RAMMING_VOLUME|float) /23.0 %}
        G1 E{0.5784 * RATIO|float} F299 #7
        G1 E{0.5834 * RATIO|float} F302 #3
        G1 E{0.5918 * RATIO|float} F306 #6
        G1 E{0.6169 * RATIO|float} F319 #6
        G1 E{0.3393 * RATIO|float} F350 #0
        G1 E{0.3363 * RATIO|float} F350 #0
        G1 E{0.7577 * RATIO|float} F392 #6
        G1 E{0.8382 * RATIO|float} F434 #3
        G1 E{0.7776 * RATIO|float} F469 #9
        G1 E{0.1293 * RATIO|float} F469 #9
        G1 E{0.9673 * RATIO|float} F501 #2
        G1 E{1.0176 * RATIO|float} F527 #2
        G1 E{0.5956 * RATIO|float} F544 #6
        G1 E{0.4555 * RATIO|float} F544 #6
        G1 E{1.0662 * RATIO|float} F552 #4
    {% endif %}

    # Set toolchange temperature just prior to filament being extracted from melt zone and wait for set point
    # (SKINNYDIP -- normal mode only)
    # Only used if changing between filament types eg. ABS-->PLA
    {% if TOOLCHANGE_TEMP|float > 0 and USE_FAST_SKINNYDIP|int == 0 %}
         M109 S{TOOLCHANGE_TEMP}
    {% endif %}

    # Unloading - This is where the tip spear shape comes from Faster=longer/pointer/higher stringing
    {% set TOTAL_RETRACTION_DISTANCE = COOLING_TUBE_POSITION|float + COOLING_TUBE_LENGTH|float / 2 - 15 %}
    G1 E-15 F{1.0 * UNLOADING_SPEED_START|float * 60} # Default value from SS - Cannot modify
    G1 E-{0.7 * TOTAL_RETRACTION_DISTANCE} F{1.0 * UNLOADING_SPEED|float * 60}
    G1 E-{0.2 * TOTAL_RETRACTION_DISTANCE} F{0.5 * UNLOADING_SPEED|float * 60}
    G1 E-{0.1 * TOTAL_RETRACTION_DISTANCE} F{0.3 * UNLOADING_SPEED|float * 60}

    {% if TOOLCHANGE_TEMP|float > 0 and USE_FAST_SKINNYDIP|int == 1 %}
        M104 S{TOOLCHANGE_TEMP}
    {% endif %}

    # Generate Cooling Moves - Solidifies tip shape and helps break strings if formed
    {% set SPEED_INC = (FINAL_COOLING_SPEED|float - INITIAL_COOLING_SPEED|float) / (2 * COOLING_MOVES|float - 1) %}
    {% for move in range(COOLING_MOVES|int) %}
        G1 E{COOLING_TUBE_LENGTH} F{(INITIAL_COOLING_SPEED|float + SPEED_INC*move*2) * 60}
        G1 E-{COOLING_TUBE_LENGTH} F{(INITIAL_COOLING_SPEED|float + SPEED_INC*(move*2+1)) * 60}
    {% endfor %}

    # Wait for extruder to reach toolchange temperature after cooling moves complete (SKINNYDIP--fast mode only)
    {% if TOOLCHANGE_TEMP|float > 0 and USE_FAST_SKINNYDIP|int == 1 %}
        M109 S{TOOLCHANGE_TEMP}
    {% endif %}

    # Skinny dip Move - burns off VERY FINE hairs (Good for PLA)
    {% if USE_SKINNYDIP|int == 1 %}
        G1 E{SKINNYDIP_DISTANCE} F{DIP_INSERTION_SPEED|float * 60}
        G4 P{MELT_ZONE_PAUSE}
        G1 E-{SKINNYDIP_DISTANCE} F{DIP_EXTRACTION_SPEED|float * 60}
        G4 P{COOLING_ZONE_PAUSE}
    {% endif %}

    {% if TOOLCHANGE_TEMP|float > 0 %}
        M104 S{OLD_TEMP}
    {% endif %}
    
    # Eject once all shaping is done - Standalone mode only
    {% if FINAL_EJECT|int == 1 %}
        G92 E0
        G1 E-80 F3000
    # Park filament at fixed location
    {% elif PARKING_DISTANCE|int > 0 %}
        G90
        M82
        G1 E-{PARKING_DISTANCE} F3000
    {% endif %}

    G92 E0
    G90
    M82


########################################################################
# Standalone Tip Cutting
#
# If you use Filametrix then a custom macro is available in `mmu/base/mmu_filametrix.cfg`
# This can be configured as an alternative to _MMU_FORM_TIP_STANDALONE by setting
#   'form_tip_macro: _MMU_CUT_TIP' in mmu_parameters.cfg
#
#
# The park position of the filament is relative to the nozzle and represents where the end of the filament is
# after tip forming. The park position is important and used by Happy Hare to finish unloading the extruder
# and for how far to advance the filament on the subsequent load. If the filament is cut it is important
# to report back the position your cutter leaves the filament in the extruder relative to the nozzle.
#
# The value can be set dynamically in gcode with this construct:
#   SET_GCODE_VARIABLE MACRO=_MMU_CUT_TIP VARIABLE=output_park_pos VALUE=-1
# or preset as a variable like this:
#   variable_output_park_pos: 35
#
########################################################################


###########################################################################
# Callback macros for modifying Happy Hare behavior
# This occurs prior to unloading filament on a toolchange
#
# Typically you would move toolhead to a position where oozing is not a problem
# when using standalone tip forming.
# Note that the z_hop is automatically controlled by Happy Hare and is
# specified with the 'z_hop_height_toolchange' parameter
#
[gcode_macro _MMU_PRE_UNLOAD]
description: Optional pre unload routine for filament change
gcode:


###########################################################################
# Callback macros for modifying Happy Hare behavior
# This occurs immediately after the tip forming or cutting procedure
#
# This is a good place to move to a position where oozing is not a problem
# in the case of Tip Cutting where moving in the _MMU_PRE_UNLOAD is too early
#
[gcode_macro _MMU_POST_FORM_TIP]
description: Optional post tip forming/cutting routing
gcode:


###########################################################################
# Callback macros for modifying Happy Hare behavior
# This occurs immediately after unloading filament on a toolchange
#
# This is a good place to inject logic to, for example, perform
# tip cutting at the MMU preping the unloaded filment for the next time
# it is loaded
#
[gcode_macro _MMU_POST_UNLOAD]
description: Optional post unload routine for filament change
gcode: EREC_CUTTER_ACTION


###########################################################################
# Callback macros for modifying Happy Hare behavior
# This occurs after loading new filament on a toolchange
#
# Typically you would clean nozzle if equiped and return to previous position
# Note that restoration to original toolhead position is ensured by Happy Hare.
#
[gcode_macro _MMU_POST_LOAD]
description: Optional post load routine for filament change
gcode:


###########################################################################
# Callback macros for modifying Happy Hare behavior
# Note that EndlessSpool is an unsupervised filament change
# This occurs prior to MMU forming tip and ejecting the remains of the old filament
#
# Typically you would move toolhead to your park position so oozing is not a problem
# Note that the z_hop is automatically controlled by Happy Hare and is
# specified with the 'z_hop_height_toolchange' parameter
#
# This is probably similar to what you do in your PAUSE macro and you could simply call that here...
# (this call works with reference PAUSE macro supplied in client_macros.cfg)
#
[gcode_macro _MMU_ENDLESS_SPOOL_PRE_UNLOAD]
description: Optional post unload routine for EndlessSpool changes
gcode:
    PAUSE

###########################################################################
# Callback macros for modifying Happy Hare behavior
# Note that EndlessSpool is an unsupervised filament change
# This occurs after MMU has loaded the new filament from the next spool in rotation
# MMU will have loaded the new filament to the nozzle the same way as a normal filament
# swap. Previously configured Pressure Advance will be retained.
# 
# This would be a place to purge additional filament if necessary (it really shouldn't be)
# and clean nozzle if your printer is suitably equipped.
# Note that restoration to original toolhead position is ensured by Happy Hare.
#
# This is probably similar to what you do in your RESUME macro and you could simply call that here...
# (this call works with reference RESUME macro supplied in client_macros.cfg)
#
[gcode_macro _MMU_ENDLESS_SPOOL_POST_LOAD]
description: Optional post load routine for EndlessSpool changes
gcode:
    RESUME


###########################################################################
# This occurs when the MMU action status changes. The `ACTION` parameter will contain
# the current action string (also available in `printer.mmu.action` printer variable).
# Also the previous action is available in `OLD_ACTION`. See Happy Hare README for
# full list of action strings.
#
# Quick Action Ref:
#  Idle|Loading|Unloading|Loading Ext|Exiting Ext|Forming Tip|Heating|Checking|Homing|Selecting
#
# The reference logic here drives a set of optional LED's
#
[gcode_macro _MMU_ACTION_CHANGED]
description: Called when an action has changed
gcode:
    {% set ACTION = params.ACTION|string %}
    {% set OLD_ACTION = params.OLD_ACTION|string %}
    {% set gate = printer['mmu']['gate'] %}

    {% if ACTION == "Loading" %}
        #_MMU_SET_LED EFFECT=mmu_pulsing_white_slow GATE={gate} EXIT_EFFECT=mmu_pulsing_white_slow
    {% elif ACTION == "Unloading" %}
        #_MMU_SET_LED EFFECT=mmu_pulsing_white_slow GATE={gate} EXIT_EFFECT=mmu_pulsing_white_slow
    {% elif ACTION == "Heating" %}
        #_MMU_SET_LED EFFECT=mmu_breathing_red GATE={gate} EXIT_EFFECT=mmu_breathing_red
    {% elif ACTION == "Idle" %}
        #_MMU_SET_LED EFFECT=default EXIT_EFFECT=default
    {% elif ACTION == "Homing" or ACTION == "Selecting" %}
        {% if OLD_ACTION != "Homing" and OLD_ACTION != "Checking" %}
            #_MMU_SET_LED EFFECT=mmu_pulsing_white_fast EXIT_EFFECT=off FADETIME=0
        {% endif %}
    {% elif ACTION == "Checking" %}
        #_MMU_SET_LED EFFECT=default EXIT_EFFECT=mmu_pulsing_white_fast
    {% endif %}


###########################################################################
# This occurs when the MMU print state changes. The `STATE` parameter will contain
# the current state string (also available in `printer.mmu.print_state` printer variable)
# Also the previous action is available in `OLD_STATE`. See Happy Hare README for
# full list of state strings and the state transition diagram.
#
# Quick State Ref:
#  initialized|ready|started|printing|complete|cancelled|error|pause_locked|paused|standby
#
# The reference logic here drives a set of optional LED's
#
[gcode_macro _MMU_PRINT_STATE_CHANGED]
description: Called when print state changes
gcode:
    {% set STATE = params.STATE|string %}
    {% set OLD_STATE = params.OLD_STATE|string %}
    {% set gate = printer['mmu']['gate'] %}

    {% if STATE == "initialized" %}
        #_MMU_SET_LED EFFECT=mmu_curtain DURATION=3
    {% elif STATE == "printing" %}
        #_MMU_SET_LED EFFECT=default
    {% elif STATE == "pause_locked" %}
        #_MMU_SET_LED EFFECT=mmu_strobe
    {% elif STATE == "paused" %}
        #_MMU_SET_LED EFFECT=mmu_strobe GATE={gate} EXIT_EFFECT=mmu_strobe
    {% elif STATE == "ready" %}
        #_MMU_SET_LED EFFECT=default EXIT_EFFECT=default
    {% elif STATE == "complete" %}
        #_MMU_SET_LED EFFECT=mmu_sparkle DURATION=20 EXIT_EFFECT=default
    {% elif STATE == "error" %}
        #_MMU_SET_LED EFFECT=mmu_strobe DURATION=20 EXIT_EFFECT=default
    {% elif STATE == "cancelled" %}
        #_MMU_SET_LED EFFECT=default EXIT_EFFECT=default
    {% elif STATE == "standby" %}
        #_MMU_SET_LED EFFECT=off EXIT_EFFECT=off
    {% endif %}


###########################################################################
# This occurs when the MMU gate_map (containing information about the filament
# type, color, availability and spoolId) is updated. The `GATE` parameter
# will contain the gate that is updated or -1 if all
#
# The reference logic here drives a set of optional LED's
#
[gcode_macro _MMU_GATE_MAP_CHANGED]
description: Called when gate map is updated
gcode:
    {% set GATE = params.GATE|int %}
   # {% set current_gate_effect = printer['gcode_macro _MMU_SET_LED']['current_gate_effect'] %}
    {% if current_gate_effect == "gate_status" or current_gate_effect == "filament_color" %}
        {% set effect=current_gate_effect %}
    {% endif %}
    #{% set current_exit_effect = printer['gcode_macro #MMU_SET_LED']['current_exit_effect'] %}
    {% if current_gate_effect == "filament_color" %}
        {% set exit_effect=current_exit_effect %}
    {% endif %}
    #_MMU_SET_LED EFFECT={effect} EXIT_EFFECT={exit_effect}



# Convenience print start marco that users can call directly from their
# slicer's custom "start g-code" or call from existing start marco
#
# To call from slicer (recommended), add these lines to your custom start
# g-code (before and after the call to your regular print start macro).
# It is recommended to separate the filament purge portion of the start
# sequence until after the initial tool is loaded.
#
#   Slicer: Custom Start g-code
#   +----------------------------------------------------------+
#   | ; Initialize MMU and save info from gcode file           |
#   | MMU_START_SETUP INITIAL_TOOL={initial_tool}              |
#   |                 REFERENCED_TOOLS=!referenced_tools!      |
#   |                 TOOL_COLORS=!colors!                     |
#   |                 TOOL_TEMPS=!temperatures!                |
#   |                 TOOL_MATERIALS=!materials!               |
#   |                 FILAMENT_NAMES=!filament_names!          |
#   |                 PURGE_VOLUMES=!purge_volumes!            |
#   |                                                          |
#   | ; Check MMU is setup for the slicer defined print        |
#   | MMU_START_CHECK                                          |
#   |                                                          |
#   | ; Bed leveling, heating logic, etc for print start       |
#   | ; (Nothing that requires filament in extruder)           |
#   | PRINT_START ; call you existing macro here..             |
#   |                                                          |
#   | ; Load slicer defined initial tool into MMU              |
#   | MMU_START_LOAD_INITIAL_TOOL                              |
#   |                                                          |
#   | ; Final purge logic before starting to print             |
#   | ..optionally call you purge logic start macro..          |
#   +----------------------------------------------------------+
#
# NOTE: The reason that it is recommended to add these 4 or 5 lines to your
# slicer is to keep them as separate gcode macros to enable the print to
# pause in the case of an error.  If you bundle everything into a single
# print start macro then the first opportunity to pause will be at the end
# of that, potentially long running, macro!
#
# Alternatively you can pass in the params to your existing print start
# macro and then insert these calls in that macro (but not recommended
# because of pause warning above)
#
#    MMU_START_SETUP {rawparams}
#    MMU_START_CHECK
#    MMU_START_LOAD_INITIAL_TOOL
#
[gcode_macro MMU_START_SETUP]
description: Called when starting print to setup MMU
gcode:
    {% set initial_tool = params.INITIAL_TOOL|default(0)|int %}
    {% set ttg_map = printer.mmu.ttg_map %}
    {% set gate_fil_names = printer.mmu.gate_filament_name %}
    {% set gate_colors = printer.mmu.gate_color %}
    {% set num_gates = ttg_map|length %}
    # {% set referenced_tools = (params.REFERENCED_TOOLS|default("!referenced_tools!")|string).split(",")
    #     if (params.REFERENCED_TOOLS and params.REFERENCED_TOOLS != "")
    #     else [] %}
    # {% set tool_colors = (params.TOOL_COLORS|default("")|string).split(",")
    #     if (params.TOOL_COLORS and params.TOOL_COLORS != "!colors!" and params.TOOL_COLORS != "")
    #     else ['000000'] * num_gates %}
    # {% set tool_temps = (params.TOOL_TEMPS|default("")|string).split(",")
    #     if (params.TOOL_TEMPS and params.TOOL_TEMPS != "!temperatures!" and params.TOOL_TEMPS != "")
    #     else ['0'] * num_gates %}
    # {% set tool_materials = (params.TOOL_MATERIALS|default("")|string).split(",")
    #     if (params.TOOL_MATERIALS and params.TOOL_MATERIALS != "!materials!" and params.TOOL_MATERIALS != "")
    #     else ['unknown'] * num_gates %}
    # {% set purge_volumes = (params.PURGE_VOLUMES|default("")|string)
    #     if (params.PURGE_VOLUMES and params.PURGE_VOLUMES != "!purge_volumes!" and params.PURGE_VOLUMES != "")
    #     else "" %}
    # {% set filament_names = (params.FILAMENT_NAMES|default("")|string).split(",")
    #     if (params.FILAMENT_NAMES and params.FILAMENT_NAMES != "!filament_names!" and params.FILAMENT_NAMES != "")
    #     else [''] * num_gates %}


    gcode:
    {% set referenced_tools = ['0', '1', '2', '3'] %}
    {% set tool_colors = ['000000', 'FF0000', '00FF00', '00FF00'] %}
    {% set tool_temps = ['220', '220', '220', '220'] %}
    {% set tool_materials = ['PLA', 'PLA', 'PLA', 'PLA'] %}
    {% set filament_names = ['Green PLA', 'Red PLA', 'Blue PLA', 'Black PLA'] %}

    # Manually create the slicer_tool_map here
    MMU_SLICER_TOOL_MAP RESET=1 PURGE_VOLUMES="10,20,30,40" NUM_SLICER_TOOLS=4 INITIAL_TOOL=0
    MMU_SLICER_TOOL_MAP TOOL=0 TEMP=220 MATERIAL='PLA' COLOR='000000' NAME='Green PLA' USED=1
    MMU_SLICER_TOOL_MAP TOOL=1 TEMP=220 MATERIAL='PLA' COLOR='00FF00' NAME='Red PLA' USED=1
    MMU_SLICER_TOOL_MAP TOOL=2 TEMP=220 MATERIAL='PLA' COLOR='00FF00' NAME='Blue PLA' USED=1
    MMU_SLICER_TOOL_MAP TOOL=2 TEMP=220 MATERIAL='PLA' COLOR='FF0000' NAME='Black PLA' USED=1

    {% set vars = printer['gcode_macro _MMU_SOFTWARE_VARS'] %}
    {% set home_mmu = vars.home_mmu|lower == 'true' %}

    {% set filament_loaded = printer.mmu.filament_pos == 10 %}
    {% set using_bypass = printer.mmu.tool == -2 %}
    {% set num_colors = referenced_tools|length %}

    {% if printer.mmu.enabled %}
        # Precaution for when printing from Octoprint (but harmless if printing from virtual SD card)
        _MMU_PRINT_START

        # Typically this would be something like a G28 to ensure homing in case of pause
        {% if not vars.user_pre_initialize_extension == "" %}
            {vars.user_pre_initialize_extension}
        {% endif %}

        # Establish number of colors in print and tools being used
        {% if referenced_tools == ['!referenced_tools!'] %}
            RESPOND MSG="Happy Hare gcode pre-processor is probably disabled or not setup correctly"
            {% set referenced_tools = [] %}
            {% set num_colors = -1 %}
        {% elif referenced_tools == [] %}
            {% set num_colors = 1 %}
        {% endif %}

        # Sanity check the parsed information
        {% set num_slicer_tools = tool_colors|length %}
        {% if tool_colors|length != num_gates or tool_temps|length != num_gates or tool_materials|length != num_gates or filament_names|length != num_gates %}
            {% if not vars.automap_strategy %}
                RESPOND MSG="Warning: Looks like slicer is setup with {num_slicer_tools} extruders but your MMU has {num_gates} gates! These should match but will attempt to continue"
            {% else %}
                RESPOND MSG="Warning: Looks like slicer is setup with {num_slicer_tools} extruders but your MMU has {num_gates} gates! Probably using auto-map feature."
            {% endif %}
        {% endif %}

        # Setup slicer tool map
        MMU_SLICER_TOOL_MAP RESET=1 PURGE_VOLUMES={purge_volumes} NUM_SLICER_TOOLS={num_slicer_tools} INITIAL_TOOL={initial_tool}
        {% for t in range(num_slicer_tools) %}
            MMU_SLICER_TOOL_MAP TOOL={t} TEMP={tool_temps[t]} MATERIAL={tool_materials[t]} COLOR={tool_colors[t]} NAME='{filament_names[t]}' {"USED=0" if t|string not in referenced_tools and t != initial_tool else ""} QUIET=1 AUTOMAP={vars.automap_strategy}
        {% endfor %}

        # Build message in case of error
        {% set custom_msg = [] %}
        {% set m = [] %}
        {% for tool in referenced_tools %}
            {% set _ = m.append("T" + tool|string + " (Gate" + ttg_map[tool|int]|string + ")") %}
        {% endfor %}
        {% set line = "Initial Tool: T%s" % initial_tool %}
        {% set _ = m.append(line) %}
        {% set _ = custom_msg.append("Print requires tools: %s" % ", ".join(m)) %}
        {% set _ = custom_msg.append("Manually ensure that T" + initial_tool|string + " is loaded and all other tools available before resuming print") %}

        # Display map summary
        {% if num_colors > 1 %}
            MMU_SLICER_TOOL_MAP SPARSE_PURGE_MAP=1 NUM_SLICER_TOOLS={num_slicer_tools}
        {% else %}
            MMU_SLICER_TOOL_MAP
        {% endif %}

        SET_GCODE_VARIABLE MACRO=_MMU_ERROR_DIALOG VARIABLE=show_abort VALUE={True} # Show abort option during startup
        {% if using_bypass and filament_loaded %}
            RESPOND MSG="MMU Bypass selected and loaded"
            {% if num_colors > 1 %}
                SET_GCODE_VARIABLE MACRO=_MMU_ERROR_DIALOG VARIABLE=custom_msg VALUE="{custom_msg}"
                MMU_PAUSE MSG="Bypass selected for multi-color print"
            {% endif %}
        {% else %}
            # Preemptively set verbose dialog message in case of additional mmu error during start
            SET_GCODE_VARIABLE MACRO=_MMU_ERROR_DIALOG VARIABLE=custom_msg VALUE="{custom_msg}"
            {% if home_mmu %}
                {% if not filament_loaded %}
                    MMU_HOME
                {% else %}
                    RESPOND MSG="Skipping homing MMU because filament is already loaded"
                {% endif %}
            {% endif %}
        {% endif %}
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_start_setup_run VALUE={True}


###########################################################################
# Helper macro to check required gates have filament. This is separated out
# from main setup macro to allow for pausing on previous error first
#
[gcode_macro MMU_START_CHECK]
description: Helper macro. Can be called to perform pre-start checks on MMU based on slicer requirements
gcode:
    {% set vars = printer['gcode_macro _MMU_SOFTWARE_VARS'] %}
    {% set check_gates = vars.check_gates|lower == 'true' %}
    {% set using_bypass = printer.mmu.tool == -2 %}

    {% if printer.mmu.enabled %}
        {% set slicer_tool_map = printer.mmu.slicer_tool_map %}
        {% set initial_tool = slicer_tool_map.initial_tool %}
        {% set tools = slicer_tool_map.referenced_tools %}
        {% if not using_bypass %}
            # Future: Could do extra checks like filament material type/color checking here
            #         to ensure what's loaded on MMU matches the slicer expectations
            {% if check_gates and tools|length > 0 %}
                # Pre-check gates option if multi-color print. Will pause if tools missing
                RESPOND MSG="Checking all required gates have filament loaded..."
                {% if not printer.mmu.is_homed %}
                    MMU_HOME
                {% endif %}
                MMU_CHECK_GATE TOOLS={tools|join(",")}
            {% endif %}
        {% endif %}
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_start_check_run VALUE={True}


###########################################################################
# Helper macro to load the initial tool. This is separated out from main
# setup macro to allow for pausing on previous error first
#
[gcode_macro MMU_START_LOAD_INITIAL_TOOL]
description: Helper to load initial tool if not paused
gcode:
    {% set vars = printer['gcode_macro _MMU_SOFTWARE_VARS'] %}
    {% set load_initial_tool = vars.load_initial_tool|lower == 'true' %}
    {% set using_bypass = printer.mmu.tool == -2 %}
    {% set filament_loaded = printer.mmu.filament_pos == 10 %}

    {% if printer.mmu.enabled %}
        {% set slicer_tool_map = printer.mmu.slicer_tool_map %}
        {% set initial_tool = slicer_tool_map.initial_tool %}
        {% set tools = slicer_tool_map.referenced_tools %}
        {% if not using_bypass and tools|length > 0 %}
            {% if load_initial_tool and (initial_tool is not none and initial_tool >= 0) %}
                RESPOND MSG="Loading initial tool T{initial_tool}..."
                MMU_CHANGE_TOOL STANDALONE=1 TOOL={initial_tool}
            {% endif %}
        {% elif not filament_loaded %}
            MMU_PAUSE MSG="Load bypass or initial tool before resuming print"
        {% else %}
            RESPOND MSG="Using bypass"
        {% endif %}
    {% endif %}

    # Important: Clear preemptive error message and remove abort option from pause dialog
    SET_GCODE_VARIABLE MACRO=_MMU_ERROR_DIALOG VARIABLE=custom_msg VALUE='""'
    SET_GCODE_VARIABLE MACRO=_MMU_ERROR_DIALOG VARIABLE=show_abort VALUE={False}
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_start_load_initial_tool_run VALUE={True}


###########################################################################
# Convenience print end marco that users can call directly from their
# slicer's custom "end g-code" or call from existing end marco
#
# To call from slicer, add this to custom end g-code (possibly as one line
# just after the call to your regular print end macro) or call directly from
# without your existing print end macro:
#
#   Slicer: Custom End g-code
#   +----------------------------------------------------------+
#   | ; Finalize MMU and optionally eject filament             |
#   | MMU_END                                                  |
#   |                                                          |
#   | ; Your existing print end macro                          |
#   | PRINT_END                                                |
#   +----------------------------------------------------------+
#
[gcode_macro MMU_END]
description: Called when ending print to finalize MMU
gcode:
    {% set eject = params.EJECT|default(0) %}
    {% set vars = printer['gcode_macro _MMU_SOFTWARE_VARS'] %}
    {% set eject_tool = vars.eject_tool|lower == 'true' %}
    {% set reset_ttg = vars.reset_ttg|lower == 'true' %}
    {% set dump_stats = vars.dump_stats|lower == 'true' %}

    {% if printer.mmu.enabled %}
        {% if eject or eject_tool %}
            MMU_EJECT
        {% endif %}

        {% if reset_ttg %}
            MMU_TTG_MAP RESET=1 QUIET=1
        {% endif %}

        {% if dump_stats %}
            MMU_STATS
        {% endif %}
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_end_run VALUE={True}


###########################################################################
# Helper macro that will walk the user through a cold-pull
#
# Assumes the bowden tube is removed from the toolhead and the extruder
# is loaded with about 300mm of filament. The use must have access to the
# filament to firmly pull when asked
#
# Params:
#  MATERIAL=nylon|pla|abs|petg	Starting temp defaults
#  HOT_TEMP			Initial high temp
#  COLD_TEMP			Temp to cool too to help release filament
#  MIN_EXTRUDE_TEMP		Temp to which the extruder will keep nozzle pressurized
#  PULL_TEMP			Temp to perform the cold pull
#  PULL_SPEED			Speed in mm/s of extruder movement to help manual pull
#  CLEAN_LENGTH			Amount of filament to extrude to prime extruder/nozzle
#  EXTRUDE_SPEED		Speed in mm/s to perform extrude operations
#
[gcode_macro MMU_COLD_PULL]
description: Guide you through the process of cleaning your extruder with a cold pull
gcode:
    {% set material = params.MATERIAL|default("pla")|string|upper %}
    {% set materials = {
        'NYLON': {'hot_temp': 260, 'cold_temp': 50, 'pull_temp': 120, 'min_extrude_temp': 190},
        'PLA':   {'hot_temp': 250, 'cold_temp': 45, 'pull_temp': 100, 'min_extrude_temp': 160},
        'ABS':   {'hot_temp': 255, 'cold_temp': 50, 'pull_temp': 120, 'min_extrude_temp': 190},
        'PETG':  {'hot_temp': 250, 'cold_temp': 45, 'pull_temp': 100, 'min_extrude_temp': 180}
    } %}
    {% if material not in materials %}
        {action_raise_error("Unknown material. Valid types are: Nylon, ABS, PLA, PTEG")}
    {% endif %}

    # Allow individual temperature overrides. Coded like this so Mainsail can parse options
    {% set hot_temp = params.HOT_TEMP|default('')|int %}
    {% set cold_temp = params.COLD_TEMP|default('')|int %}
    {% set pull_temp = params.PULL_TEMP|default('')|int %}
    {% set min_extrude_temp = params.MIN_EXTRUDE_TEMP|default('')|int %}
    {% set hot_temp = (hot_temp if hot_temp > 0 else materials.get(material).hot_temp)|int %}
    {% set cold_temp = (cold_temp if cold_temp > 0 else materials.get(material).cold_temp)|int %}
    {% set pull_temp = (pull_temp if pull_temp > 0 else materials.get(material).pull_temp)|int %}
    {% set min_extrude_temp = (min_extrude_temp if min_extrude_temp > 0 else materials.get(material).min_extrude_temp)|int %}

    {% set pull_speed = params.PULL_SPEED|default(10)|int %}
    {% set clean_length = params.CLEAN_LENGTH|default(25)|int %}
    {% set extrude_speed = params.EXTRUDE_SPEED|default(1.5)|float %}

    {% set ns = namespace(stuff_points=[], cool_points=[]) %}

    {% for temp in range(hot_temp + 1, cold_temp - 1, -1) %}
        {% if temp % 10 == 0 %}
            {% if temp > min_extrude_temp %}
                {% set ns.stuff_points = ns.stuff_points + [temp] %}
            {% elif temp < min_extrude_temp %}
                {% set ns.cool_points = ns.cool_points + [temp] %}
            {% endif %}
        {% endif %}
    {% endfor %}

    RESPOND MSG='{"Cold Pull with pull_temp=%d\u00B0C, hot_temp=%d\u00B0C, min_extrude_temp=%d\u00B0C, cold_temp=%d\u00B0C" % (pull_temp, hot_temp, min_extrude_temp, cold_temp)}'

    RESPOND MSG='{"Heating extruder to %d\u00B0C" % hot_temp}'
    SET_HEATER_TEMPERATURE HEATER="extruder" TARGET={hot_temp}
    TEMPERATURE_WAIT SENSOR="extruder" MINIMUM={hot_temp - 2} MAXIMUM={hot_temp + 2}

    # Ensure the nozzle id completely full
    RESPOND MSG="Cleaning nozzle tip with {clean_length}mm of filament"
    _MMU_STEP_MOVE MOTOR="extruder" MOVE={clean_length} SPEED={extrude_speed}

    # Begin the cooling ramp
    RESPOND MSG="Allowing extruder to cool..."
    SET_HEATER_TEMPERATURE HEATER="extruder" TARGET={cold_temp}
    M106 S255			# 100% part fan to cool faster

    # While filament can still extrude keep the nozzle completely full
    {% for temp in ns.stuff_points %}
        TEMPERATURE_WAIT SENSOR="extruder" MAXIMUM={temp}
        RESPOND MSG='{"Stuffing nozzle at %d\u00B0C" % temp}'
        _MMU_STEP_MOVE MOTOR="extruder" MOVE=1 SPEED={extrude_speed}
    {% endfor %}

    # Give some feedback on cooling process
    RESPOND MSG='{"Waiting for extruder to completely cool to %d\u00B0C..." % cold_temp}'
    {% for temp in ns.cool_points %}
        TEMPERATURE_WAIT SENSOR="extruder" MAXIMUM={temp}
        RESPOND MSG='{"Nozzle at %d\u00B0C" % temp}'
    {% endfor %}
    TEMPERATURE_WAIT SENSOR="extruder" MAXIMUM={cold_temp}

    # Re-warm
    M107			# Part fan off
    RESPOND MSG='{"Re-warming extruder to %d\u00B0C" % pull_temp}'
    SET_HEATER_TEMPERATURE HEATER="extruder" TARGET={pull_temp}

    # The manual cold-pull
    TEMPERATURE_WAIT SENSOR="extruder" MINIMUM={pull_temp - 10}
    RESPOND MSG="Get ready to pull..."
    TEMPERATURE_WAIT SENSOR="extruder" MINIMUM={pull_temp}
    RESPOND MSG=">>>>> PULL NOW <<<<<"

    # Retract 150 mm at moderate speed (user should pull too)
    _MMU_STEP_MOVE MOTOR="extruder" MOVE=-150 SPEED={pull_speed}
    RESPOND MSG="Cold pull is successful if you can see the shape of the nozzle at the filament end"

    # Heater completely off
    SET_HEATER_TEMPERATURE HEATER="extruder"


###########################################################################
# Helper macros to display dialog in supporting UI's when MMU pauses
#
[gcode_macro _MMU_ERROR_DIALOG]
description: Helper to display pause dialog
variable_custom_msg: '' # List of additional custom message lines to append in dialog
variable_show_abort: False
gcode:
    {% set message = params.MSG|string %}
    {% set reason = params.REASON|string %}
    RESPOND TYPE=command MSG="action:prompt_begin Happy Hare Error Notice"
    RESPOND TYPE=command MSG='{"action:prompt_text %s" % message}'
    RESPOND TYPE=command MSG='{"action:prompt_text Reason: %s" % reason}'
    {% if not custom_msg == "" %}
        {% for line in custom_msg %}
            RESPOND TYPE=command MSG='{"action:prompt_text %s" % line}'
        {% endfor %}
    {% else %}
        RESPOND TYPE=command MSG="action:prompt_text After fixing, call RESUME to continue printing (MMU_UNLOCK to restore temperature)"
    {% endif %}
    RESPOND TYPE=command MSG="action:prompt_button_group_start"
    {% if show_abort %}
        RESPOND TYPE=command MSG="action:prompt_button ABORT|CANCEL_PRINT|error"
    {% endif %}
    RESPOND TYPE=command MSG="action:prompt_button UNLOCK|MMU_UNLOCK|secondary"
    RESPOND TYPE=command MSG="action:prompt_button RESUME|RESUME|warning"
    RESPOND TYPE=command MSG="action:prompt_button_group_end"
    RESPOND TYPE=command MSG="action:prompt_show"
    {% set custom_msg = "" %}


###########################################################################
# Helper for Klippain to reset start/end step "run" trackers
#
[gcode_macro _MMU_RUN_MARKERS]
variable_mmu_start_setup_run: False
variable_mmu_start_check_run: False
variable_mmu_start_load_initial_tool_run: False
variable_mmu_end_run: False
gcode:
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_start_setup_run VALUE=False
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_start_check_run VALUE=False
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_start_load_initial_tool_run VALUE=False
    SET_GCODE_VARIABLE MACRO=_MMU_RUN_MARKERS VARIABLE=mmu_end_run VALUE=False


###########################################################################
# Control macro for MMU neopixel or dotstar leds
#
[gcode_macro _MMU_SET_LED]
description: Called when print state changes

# Control the operation of MMU LED's. 0=Disabled (if you don't have neopixels for each gate)
variable_led_enable: 1

# Name of the neopixel or dotstar strip. Use complete name line in quotes e.g. "neopixel:mmu_leds"
variable_leds: "neopixel:mmu_leds"

# Default effect for gate LEDs.  This can be any effect or "r,g,b" color,
# but these are built-in functional effects:
# "off"             - LED's off when on action occuring
# "gate_status"     - indicate gate availability
# "filament_color"  - indicate filament color
variable_default_gate_effect: "gate_status"

# Default effect for exit LED, perhaps lighting the PTFE tube. This can be
# any effect or "r,g,b" color, but these are built-in functional effects:
# "off"             - LED's off except when on action occuring
# "on"              - LED's white (could be any effect or "r,g,b" color)
# "filament_color"  - indicate current filament color or white if not set
variable_default_exit_effect: "filament_color"

# Reverse chain order. If disabled (default), Gate 0 is LED index 1
# If enabled, Gate N is LED index 1
variable_reverse_gate_order: 0

variable_current_gate_effect: "none"		# Internal state, don't mess
variable_current_exit_effect: "none"		# Internal state, don't mess

gcode:
    {% if printer['gcode_macro _MMU_SET_LED']['led_enable'] > 0 %}
        {% set leds = printer['gcode_macro _MMU_SET_LED']['leds'] %}
        {% set leds_name = leds.split(':')[1] %}
        {% set EFFECT = params.EFFECT|default("")|string %}
        {% set GATE = params.GATE|default(-1)|int %}
        {% set EXIT_EFFECT = params.EXIT_EFFECT|default("")|string %}
        {% set DURATION = params.DURATION|default(-1)|int %}
        {% set FADETIME = params.FADETIME|default(1)|int %}

        # Grab useful printer variables
        {% set gate_status = printer['mmu']['gate_status'] %}
        {% set gate_color = printer['mmu']['gate_color'] %}
        {% set gate_color_rgb = printer['mmu']['gate_color_rgb'] %}
        {% set filament_pos = printer['mmu']['filament_pos'] %}
        {% set white_light = (1,1,1) %}
        {% set black_light = (0.01,0,0.02) %}
        {% set empty_light = (0,0,0) %}

        # Determine LED indexes. Gates always first followed by "exit" LED
        {% set exit_index = gate_status|length + 1 %}
        {% if printer['gcode_macro _MMU_SET_LED']['reverse_gate_order'] == 1 %}
            {% set index = gate_status|length - GATE %}
            {% set count = -1 %}
            {% set first = gate_status|length %}
        {% else %}
            {% set index = GATE + 1 %}
            {% set count = 1 %}
            {% set first = 1 %}
        {% endif %}

        {% if DURATION > 0 %}
            UPDATE_DELAYED_GCODE ID=_MMU_RESET_LED DURATION={DURATION}
        {% else %}
            UPDATE_DELAYED_GCODE ID=_MMU_RESET_LED DURATION=0
        {% endif %}

        {% if EFFECT == "default" %}
            {% set EFFECT = printer['gcode_macro _MMU_SET_LED']['default_gate_effect'] %}
        {% endif %}
        {% if EXIT_EFFECT == "default" %}
            {% set EXIT_EFFECT = printer['gcode_macro _MMU_SET_LED']['default_exit_effect'] %}
        {% endif %}

        SET_GCODE_VARIABLE MACRO=#_MMU_SET_LED VARIABLE=current_gate_effect VALUE='"{EFFECT}"'
        SET_GCODE_VARIABLE MACRO=#_MMU_SET_LED VARIABLE=current_exit_effect VALUE='"{EXIT_EFFECT}"'

        # Gate effects...
        {% if EFFECT == "off" %}
            {% if GATE >= 0 %}
                STOP_LED_EFFECTS LEDS="{leds} ({index})" FADETIME={FADETIME}
                SET_LED LED={leds_name} INDEX={index} RED=0 GREEN=0 BLUE=0 TRANSMIT=1
            {% else %}
                STOP_LED_EFFECTS LEDS={leds} FADETIME={FADETIME}
                SET_LED LED={leds_name} RED=0 GREEN=0 BLUE=0 TRANSMIT=1
            {% endif %}

        {% elif EFFECT == "gate_status" %} # Filament availability
            {% if GATE >= 0 %}
                {% if gate_status[GATE] == -1 %}
                    #SET_LED_EFFECT EFFECT=mmu_orange_{index} FADETIME={FADETIME} REPLACE=1
                {% elif gate_status[GATE] > 0 %}
                    #SET_LED_EFFECT EFFECT=mmu_green_{index} FADETIME={FADETIME} REPLACE=1
                {% else %}
                    STOP_LED_EFFECTS LEDS="{leds} ({index})" FADETIME={FADETIME}
                {% endif %}
            {% else %}
                {% set ns = namespace(index = first) %}
                {% for status in gate_status %}
                    {% if status == -1 %}
                        #SET_LED_EFFECT EFFECT=mmu_orange_{ns.index} FADETIME={FADETIME} REPLACE=1
                    {% elif status > 0 %}
                        #SET_LED_EFFECT EFFECT=mmu_green_{ns.index} FADETIME={FADETIME} REPLACE=1
                    {% else %}
                        STOP_LED_EFFECTS LEDS="{leds} ({ns.index})" FADETIME={FADETIME}
                        SET_LED LED={leds_name} INDEX={ns.index} RED=0 GREEN=0 BLUE=0 TRANSMIT=1
                    {% endif %}
                    {% set ns.index = ns.index + count %}
                {% endfor %}
            {% endif %}

        {% elif EFFECT == "filament_color" %} # Filament color
            {% if GATE >= 0 %}
                {% set rgb = gate_color_rgb[GATE] %}
                STOP_LED_EFFECTS LEDS="{leds} ({index})"
                SET_LED LED={leds_name} INDEX={index} RED={rgb[0]} GREEN={rgb[1]} BLUE={rgb[2]} TRANSMIT=1
            {% else %}
                STOP_LED_EFFECTS LEDS={leds}
                {% set ns = namespace(index = first, gate = 0) %}
                {% for rgb in gate_color_rgb %}
                    {% if gate_status[ns.gate] != 0 %}
                        {% if gate_color[ns.gate] == "" %}
                            {% set rgb = white_light %}
                        {% elif rgb == (0,0,0) %}
                            {% set rgb = black_light %}
                        {% endif %}
                    {% else %}
                        {% set rgb = empty_light %}
                    {% endif %}
                    SET_LED LED={leds_name} INDEX={ns.index} RED={rgb[0]} GREEN={rgb[1]} BLUE={rgb[2]} TRANSMIT=1
                    {% set ns.index = ns.index + count %}
                    {% set ns.gate = ns.gate + 1 %}
                {% endfor %}
            {% endif %}

        {% elif "," in EFFECT %} # Not effect, just simple RGB color
            {% set rgb = EFFECT.split(",") %}
            {% if GATE >= 0 %}
                STOP_LED_EFFECTS LEDS="{leds} ({index})"
                SET_LED LED={leds_name} INDEX={index} RED={rgb[0]} GREEN={rgb[1]} BLUE={rgb[2]} TRANSMIT=1
            {% else %}
                STOP_LED_EFFECTS LEDS={leds}
                SET_LED LED={leds_name} RED={rgb[0]} GREEN={rgb[1]} BLUE={rgb[2]} TRANSMIT=1
            {% endif %}

        {% elif EFFECT != "" %} # Simple effect by name
            {% if GATE >= 0 %}
                #SET_LED_EFFECT EFFECT={EFFECT}_{index} FADETIME={FADETIME} REPLACE=1
            {% else %}
                #SET_LED_EFFECT EFFECT={EFFECT} FADETIME={FADETIME} REPLACE=1
            {% endif %}
        {% endif %}

        # Exit effects...
        {% if EXIT_EFFECT == "off" %}
            STOP_LED_EFFECTS LEDS="{leds} ({exit_index})" FADETIME={FADETIME}
            SET_LED LED={leds_name} INDEX={exit_index} RED=0 GREEN=0 BLUE=0 TRANSMIT=1

        {% elif EXIT_EFFECT == "filament_color" or EXIT_EFFECT == "on" %} # Filament color
            {% set gate = printer['mmu']['gate'] %}
            STOP_LED_EFFECTS LEDS="{leds} ({exit_index})"
            {% if gate >= 0 and filament_pos > 0 %}
                {% if EXIT_EFFECT != "on" and gate_color[gate] != "" %}
                    {% set rgb = gate_color_rgb[gate] %}
                {% else %}
                    {% set rgb = white_light %}
                {% endif %}
                SET_LED LED={leds_name} INDEX={exit_index} RED={rgb[0]} GREEN={rgb[1]} BLUE={rgb[2]} TRANSMIT=1
            {% else %}
                SET_LED LED={leds_name} INDEX={exit_index} RED=0 GREEN=0 BLUE=0 TRANSMIT=1
            {% endif %}

        {% elif "," in EXIT_EFFECT %} # No effect, just simple RGB color
            {% set rgb = EXIT_EFFECT.split(",") %}
            STOP_LED_EFFECTS LEDS="{leds} ({exit_index})"
            SET_LED LED={leds_name} INDEX={exit_index} RED={rgb[0]} GREEN={rgb[1]} BLUE={rgb[2]} TRANSMIT=1

        {% elif EXIT_EFFECT != "" %} # Simple effect by name
            #SET_LED_EFFECT EFFECT={EXIT_EFFECT}_{exit_index} FADETIME={FADETIME} REPLACE=1
        {% endif %}
    {% endif %}


###########################################################################
# Helper for LED control
#
[delayed_gcode _MMU_RESET_LED]
gcode:
    #_MMU_SET_LED EFFECT=default EXIT_EFFECT=default


###########################################################################
# ADVANCED: User modifable loading and unloading sequences
#
# By default Happy Hare will call internal logic to handle loading and unloading
# sequences. To enable the calling of user defined sequences you must add the
# following to your mmu_parameters.cfg
#
# gcode_load_sequence: 1	# Gcode loading sequence 1=enabled, 0=internal logic (default)
# gcode_unload_sequence: 1	# Gcode unloading sequence, 1=enabled, 0=internal logic (default)
#
# This reference example load sequence mimicks the internal ones exactly. It uses the
# high level "modular" movements that are all controlled by parameters defined in
# mmu_parameters.cfg and automatically keep the internal filament position state up-to-date.
# Switching to these macros should not change behavior and can serve as a starting point for
# your customizations
#
# State Machine:
# If you experiment beyond the basic example shown here you will need to understand
# the possible states for filament position.  This is the same state that is exposed
# as the `printer.mmu.filament_pos` printer variable. This internal state must be
# kept up-to-date and will need to be set directly as you progress through your
# custom move sequence.  At this time the state machine is non-extensible.
#
#        FILAMENT_POS_UNKNOWN = -1
#  L  ^  FILAMENT_POS_UNLOADED = 0
#  O  |  FILAMENT_POS_START_BOWDEN = 1
#  A  |  FILAMENT_POS_IN_BOWDEN = 2
#  D  U  FILAMENT_POS_END_BOWDEN = 3
#  |  N  FILAMENT_POS_HOMED_EXTRUDER = 4
#  |  L  FILAMENT_POS_PAST_EXTRUDER = 5
#  |  O  FILAMENT_POS_HOMED_TS = 6
#  |  A  FILAMENT_POS_IN_EXTRUDER = 7    # AKA Filament is past the Toolhead Sensor
#  v  D  FILAMENT_POS_LOADED = 8         # AKA Filament is homed to the nozzle
#
# Final notes:
# 1) You need to respect the context being passed into the macro such as the
#    desired 'length' to move because this can be called for test loading
# 2) The unload macro can be called with the filament in any position (states)
#    You are required to handle any starting point. The default reference
#    serves as a good guide
#
[gcode_macro _MMU_LOAD_SEQUENCE]
description: Called when MMU is asked to load filament
gcode:
    {% set filament_pos = params.FILAMENT_POS|float %}
    {% set length = params.LENGTH|float %}
    {% set full = params.FULL|int %}
    {% set home_extruder = params.HOME_EXTRUDER|int %}
    {% set skip_extruder = params.SKIP_EXTRUDER|int %}
    {% set extruder_only = params.EXTRUDER_ONLY|int %}

    {% if extruder_only %}
        _MMU_STEP_LOAD_TOOLHEAD EXTRUDER_ONLY=1

    {% elif filament_pos >= 5 %}
        {action_raise_error("Can't load - already in extruder!")}

    {% else %}
        {% if filament_pos <= 0 %}                      # FILAMENT_POS_UNLOADED
            _MMU_STEP_LOAD_GATE
        {% endif %}

        {% if filament_pos < 3 %}                       # FILAMENT_POS_END_BOWDEN
            _MMU_STEP_LOAD_BOWDEN LENGTH={length}
        {% endif %}

        {% if filament_pos < 4 and home_extruder %}     # FILAMENT_POS_HOMED_EXTRUDER
            _MMU_STEP_HOME_EXTRUDER
        {% endif %}

        {% if not skip_extruder %}                      # FILAMENT_POS_PAST_EXTRUDER
            _MMU_STEP_LOAD_TOOLHEAD
        {% endif %}

    {% endif %}

[gcode_macro _MMU_UNLOAD_SEQUENCE]
description: Called when MMU is asked to unload filament
gcode:
    {% set filament_pos = params.FILAMENT_POS|float %}
    {% set length = params.LENGTH|float %}
    {% set extruder_only = params.EXTRUDER_ONLY|int %}
    {% set park_pos = params.PARK_POS|float %}

    {% if extruder_only %}
        {% if filament_pos >= 5 %}                      # FILAMENT_POS_PAST_EXTRUDER
            _MMU_STEP_UNLOAD_TOOLHEAD EXTRUDER_ONLY=1 PARK_POS={park_pos}
        {% else %}
            {action_raise_error("Can't unload extruder - already unloaded!")}
        {% endif %}

    {% elif filament_pos == 0 %}
        {action_raise_error("Can't unload - already unloaded!")}

    {% else %}
        {% if filament_pos >= 5 %}                      # FILAMENT_POS_PAST_EXTRUDER
            # Exit extruder, fast unload of bowden, then slow unload encoder
            _MMU_STEP_UNLOAD_TOOLHEAD PARK_POS={park_pos}
        {% endif %}

        {% if filament_pos >= 3 %}                      # FILAMENT_POS_END_BOWDEN
            # Fast unload of bowden, then slow unload encoder
            _MMU_STEP_UNLOAD_BOWDEN FULL=1
            _MMU_STEP_UNLOAD_GATE

        {% elif filament_pos >= 1 %}                    # FILAMENT_POS_START_BOWDEN
            # Have to do slow unload because we don't know exactly where in the bowden we are
            _MMU_STEP_UNLOAD_GATE FULL=1
        {% endif %}

    {% endif %}

#
# Some examples of alternative macros follow
#
# 1. This loading example leverages the built-in modules to load filament to the end
# of the bowden tube. Then homes the filament to the toolhead sensor (mmu_toolhead)
# using synchronized gear and extruder movement. The state is updated to reflect this
# new position. It then performs a synchronized stepper move of 62mm to advance the
# filament to the nozzle
#
#[gcode_macro _MMU_LOAD_SEQUENCE]
#description: Called when MMU is asked to load filament
#gcode:
#    {% set filament_pos = params.FILAMENT_POS|float %}
#    {% set length = params.LENGTH|float %}
#    {% set skip_extruder = params.SKIP_EXTRUDER|int %}
#    {% set extruder_only = params.EXTRUDER_ONLY|int %}
#
#    {% if extruder_only %}
#        _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_toolhead MOVE=50 MOTOR=extruder
#        _MMU_STEP_SET_FILAMENT STATE=6		# FILAMENT_POS_HOMED_TS
#        _MMU_STEP_MOVE MOVE=62 MOTOR=extruder
#        _MMU_STEP_SET_FILAMENT STATE=8		# FILAMENT_POS_LOADED
#    {% else %}
#        _MMU_STEP_LOAD_GATE
#        _MMU_STEP_LOAD_BOWDEN LENGTH={length}
#        {% if full and not skip_extruder %}
#            _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_toolhead MOVE=50 MOTOR=gear+extruder
#            _MMU_STEP_SET_FILAMENT STATE=6	# FILAMENT_POS_HOMED_TS
#            _MMU_STEP_MOVE MOVE=62 MOTOR=gear+extruder
#            _MMU_STEP_SET_FILAMENT STATE=8	# FILAMENT_POS_LOADED
#        {% endif %}
#    {% endif %}
#
#
# 2. This very streamlined loading example starts off similarly loading to the end of the
# calibrated bowden. It then simply homes to the nozzle (using TMC stallguard on the extruder
# stepper!) with synchronized extruder+gear steppers.  This requires the `mmu_ext_touch`
# endstop to be one of those defined for the extruder stepper
#
#[gcode_macro _MMU_LOAD_SEQUENCE]
#description: Called when MMU is asked to load filament
#gcode:
#    {% set length = params.LENGTH|float %}
#    {% set full = params.FULL|int %}
#    {% set skip_extruder = params.SKIP_EXTRUDER|int %}
#    {% set extruder_only = params.EXTRUDER_ONLY|int %}
#
#    {% if extruder_only %}
#        _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_ext_touch MOVE=100 MOTOR=extruder
#        _MMU_STEP_SET_FILAMENT STATE=8	# FILAMENT_POS_LOADED
#    {% else %}
#        _MMU_STEP_LOAD_GATE
#        _MMU_STEP_LOAD_BOWDEN LENGTH={length}
#        {% if full and not skip_extruder %}
#            _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_ext_touch MOVE=100 MOTOR=extruder+gear
#            _MMU_STEP_SET_FILAMENT STATE=8	# FILAMENT_POS_LOADED
#        {% endif %}
#    {% endif %}

